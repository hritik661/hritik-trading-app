<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hritik Indian Stock Market Live</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body class="dark">
  <div class="header">
    <h1 class="logo">Hritik Indian Stock Market Live</h1>
    <div class="header-date">
      Live Market Data • <span id="currentDate"></span> • Wallet: <span id="walletBalance">₹1,00,00,000</span>
    </div>
    <button class="holding-toggle" onclick="toggleHoldings()" title="Show Holdings" aria-label="Show Holdings">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#F3F4F6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" id="holdingsIcon">
        <path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/>
        <path d="M8 6V4c0-1.1.9-2 2-2h4c1.1 0 2 .9 2 2v2"/>
        <path d="M10 12h4"/>
      </svg>
      Holdings
    </button>
    <button class="theme-toggle" onclick="toggleTheme()" title="Switch Theme" aria-label="Toggle Theme">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
        <path id="lightIcon" d="M12 17C14.7614 17 17 14.7614 17 12C17 9.23858 14.7614 7 12 7C9.23858 7 7 9.23858 7 12C7 14.7614 9.23858 17 12 17Z M12 1V3M12 21V23M4.22 4.22L5.64 5.64M18.36 18.36L19.78 19.78M1 12H3M21 12H23M4.22 19.78L5.64 18.36M18.36 5.64L19.78 4.22" stroke="#1F2A44" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style="display: none;"/>
        <path id="darkIcon" d="M21 12.79C20.8427 14.4922 20.2039 16.1144 19.1582 17.4668C18.1126 18.8192 16.7035 19.8458 15.0957 20.4265C13.4879 21.0073 11.7479 21.1181 10.0795 20.7461C8.41111 20.3741 6.88058 19.5345 5.67453 18.3285C4.46847 17.1224 3.62885 15.5919 3.25689 13.9235C2.88493 12.2551 2.99571 10.5151 3.57648 8.9073C4.15725 7.29952 5.18387 5.89039 6.53618 4.84474C7.88849 3.79908 9.51071 3.16029 11.213 3.00303C10.2555 4.1482 9.75149 5.59284 9.79786 7.06901C9.84423 8.54517 10.4382 9.95479 11.4743 11.0358C12.5103 12.1168 13.9241 12.7832 15.4036 12.9052C16.8831 13.0272 18.3608 12.6954 19.597 11.897C20.137 12.1643 20.6073 12.4531 21 12.79Z" stroke="#F3F4F6" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    </button>
  </div>

  <div class="portfolio-section" id="portfolioSection" style="display: none; position: relative;">
    <h2 class="portfolio-title">Portfolio (Holdings)</h2>
    <button class="portfolio-close" onclick="toggleHoldings()" title="Close Portfolio" aria-label="Close Portfolio">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#F3F4F6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18" />
        <line x1="6" y1="6" x2="18" y2="18" />
      </svg>
    </button>
    <div class="portfolio-stats">
      <p>Total Invested: <span id="totalInvested">₹0</span></p>
      <p>Current Value: <span id="currentValue">₹0</span></p>
      <p>Profit/Loss: <span id="profitLoss">₹0</span></p>
    </div>
    <div id="portfolioContainer" class="portfolio-grid"></div>
  </div>

  <div class="search-bar">
    <form id="searchForm">
        <input type="text" id="searchInput" placeholder="Search For any Stock" />
        <div class="placeholder-wrapper">
            <svg class="placeholder-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <span class="placeholder-text">Search For any Stock </span>
        </div>
        <button type="submit">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            Search
        </button>
    </form>
</div>

  <div id="searchResult" role="alert"></div>
  <div id="notificationMessage" class="notification"></div>

  <div class="top-stocks">
    <h2 class="top-stocks-title">Most Traded Stocks</h2>
    <div class="top-stocks-container" id="topStocksContainer"></div>
  </div>

  <div class="indices-buttons">
    <button class="index-button active" onclick="toggleHistoricalData('^NSEI', 'NIFTY 50')" aria-label="NIFTY 50">NIFTY 50</button>
    <button class="index-button" onclick="toggleHistoricalData('^BSESN', 'SENSEX')" aria-label="SENSEX">SENSEX</button>
    <button class="index-button" onclick="toggleHistoricalData('^NSEBANK', 'BANK NIFTY')" aria-label="BANK NIFTY">BANK NIFTY</button>
    <button class="index-button" onclick="toggleHistoricalData('^NSEMDCP50', 'NIFTY MIDCAP 50')" aria-label="NIFTY MIDCAP 50">NIFTY MIDCAP 50</button>
    <button class="index-button" onclick="toggleBitcoinData('BTCUSDT', 'Bitcoin (BTC/USDT)')" aria-label="Bitcoin (BTC/USDT)">BTC/USDT</button>
  </div>

  <div class="content-grid">
    <div class="chart-section">
      <div id="chartContainer">
        <button id="toggleChartType" onclick="toggleChartType()" aria-label="Switch Chart Type">Switch to Candlestick</button>
        <canvas id="stockChart" aria-label="Stock Chart"></canvas>
      </div>
      <div id="priceInfo"></div>
    </div>

    <div class="price-dashboard">
      <h2 class="dashboard-title">Market Overview</h2>
      <div id="stockCards"></div>
    </div>
  </div>

  <div class="predictions-section">
    <h2 class="predictions-title">Predicted Stock Gainers (5%+ Up)</h2>
    <div class="predictions-container" id="predictionsContainer"></div>
  </div>
  
  <div class="losers-section">
    <h2 class="losers-title">Biggest Losers (Down 30%+ from 52-Week High)</h2>
    <div class="losers-container" id="losersContainer"></div>
  </div>
  
  <div class="news-section">
    <h2 class="news-title">Latest Stock Trading News</h2>
    <div class="news-container" id="newsContainer"></div>
  </div>
  <script>
    
  let ws;
  let binanceWs;
  const stockCards = document.getElementById('stockCards');
  const topStocksContainer = document.getElementById('topStocksContainer');
  const searchResult = document.getElementById('searchResult');
  const notificationMessage = document.getElementById('notificationMessage');
  const searchInput = document.getElementById('searchInput');
  const chartContainer = document.getElementById('chartContainer');
  const toggleChartTypeButton = document.getElementById('toggleChartType');
  const priceInfo = document.getElementById('priceInfo');
  const portfolioSection = document.getElementById('portfolioSection');
  let currentChartType = 'line';
  let currentData = null;
  let currentSymbol = '^NSEI';
  let activeSymbol = '^NSEI';
  let isIndex = true;
  let currentTheme = 'dark';
  let stockChart = null;
  let walletBalance = 10000000; // ₹1 crore initial balance
  let portfolio = JSON.parse(localStorage.getItem('portfolio')) || {};
  // Normalize existing portfolio symbols
  Object.keys(portfolio).forEach(symbol => {
    if (!symbol.endsWith('.NS')) {
      const newSymbol = `${symbol}.NS`;
      portfolio[newSymbol] = portfolio[symbol];
      delete portfolio[symbol];
    }
  });
  localStorage.setItem('portfolio', JSON.stringify(portfolio));
  let totalInvested = 0;
  let currentValue = 0;
  let profitLoss = 0;
  let indexData = {
    '^NSEI': { name: 'NIFTY 50', price: 23598.95, lastClose: 23653.85, percentChange: -0.23 },
    '^BSESN': { name: 'SENSEX', price: 77935.45, lastClose: 78227.08, percentChange: -0.37 },
    '^NSEBANK': { name: 'BANK NIFTY', price: 50515.05, lastClose: 50851.15, percentChange: -0.66 },
    '^NSEMDCP50': { name: 'NIFTY MIDCAP 50', price: 14035.8, lastClose: 14064.25, percentChange: -0.20 },
    'BTCUSDT': { name: 'Bitcoin (BTC/USDT)', price: 60000, lastClose: 59000, percentChange: 1.69, volume: 0 }
  };
  let lastNewsData = null;
  let lastIndicesData = null;
  let lastStocksData = null;
  let lastLosersData = null;
  let lastPredictionsData = null;
  let currentPredictionDate = null;
  
  document.getElementById('currentDate').textContent = new Date().toLocaleDateString("en-IN", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
  
  function updateWalletBalance() {
    document.getElementById('walletBalance').textContent = 
      `₹${walletBalance.toLocaleString('en-IN', { maximumFractionDigits: 2 })}`;
  }
  
  function updatePortfolioStats() {
    totalInvested = 0;
    currentValue = 0;
    Object.values(portfolio).forEach(holding => {
      if (holding.quantity && holding.avgPrice && holding.currentPrice) {
        totalInvested += holding.quantity * holding.avgPrice;
        currentValue += holding.quantity * holding.currentPrice;
      }
    });
    profitLoss = currentValue - totalInvested;
    document.getElementById('totalInvested').textContent = `₹${totalInvested.toLocaleString('en-IN', { maximumFractionDigits: 2 })}`;
document.getElementById('currentValue').textContent = `₹${currentValue.toLocaleString('en-IN', { maximumFractionDigits: 2 })}`;    document.getElementById('profitLoss').textContent = 
      `${profitLoss >= 0 ? '+' : '-'}₹${Math.abs(profitLoss).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`;
    document.getElementById('profitLoss').className = profitLoss >= 0 ? 'positive' : 'negative';
    localStorage.setItem('portfolio', JSON.stringify(portfolio));
  }
  
  function renderPortfolio() {
    const portfolioContainer = document.getElementById('portfolioContainer');
    portfolioContainer.innerHTML = '';
    isIndex = false; // Portfolio contains stocks, not indices
    
    if (Object.keys(portfolio).length === 0) {
        portfolioContainer.innerHTML = '<p class="no-holdings">No holdings yet. Start trading to add stocks!</p>';
        updatePortfolioStats();
        return;
    }
    
    // First create and add all cards to the DOM
    Object.entries(portfolio).forEach(([symbol, holding], idx) => {
        if (!holding.name || !holding.quantity || !holding.avgPrice) {
            return;
        }
        
        const currentPrice = holding.currentPrice && !isNaN(holding.currentPrice) && holding.currentPrice > 0 ? holding.currentPrice : 0;
        const volume = holding.volume && !isNaN(holding.volume) ? Number(holding.volume).toLocaleString('en-IN') : 'N/A';
        const dayHigh = holding.dayHigh && !isNaN(holding.dayHigh) ? `₹${Number(holding.dayHigh).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';
        const dayLow = holding.dayLow && !isNaN(holding.dayLow) ? `₹${Number(holding.dayLow).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';
        
        const pl = currentPrice ? (currentPrice - holding.avgPrice) * holding.quantity : 0;
        const plPercent = currentPrice ? ((currentPrice - holding.avgPrice) / holding.avgPrice * 100) : 0;
        
        // Create the card element
        const card = document.createElement('div');
        card.className = 'portfolio-card';
        card.style.animationDelay = `${0.1 + (idx * 0.05)}s`;
        card.setAttribute('data-symbol', symbol);
        
        card.innerHTML = `
            <div class="portfolio-info">
                <h3 class="portfolio-name">${holding.name}</h3>
                <p>Quantity: ${holding.quantity}</p>
                <p>Avg. Price: ₹${holding.avgPrice.toLocaleString('en-IN', { maximumFractionDigits: 2 })}</p>
                <p>Current Price: ₹${currentPrice.toLocaleString('en-IN', { maximumFractionDigits: 2 })}</p>
                <p>Volume: ${volume}</p>
                <p>Day High: ${dayHigh}</p>
                <p>Day Low: ${dayLow}</p>
                <p class="${pl >= 0 ? 'positive' : 'negative'}" style="${pl < 0 ? 'color: #FF3333' : ''}">
                    P/L: ${pl >= 0 ? '+' : '-'}₹${Math.abs(pl).toLocaleString('en-IN', { maximumFractionDigits: 2 })} 
                    (${plPercent >= 0 ? '+' : ''}${plPercent.toFixed(2)}%)
                </p>
                <div class="stock-actions" data-symbol="${symbol}">
                    <!-- Buttons will be added separately -->
                </div>
            </div>
        `;
        
        portfolioContainer.appendChild(card);
    });
    
    // Now add buttons separately after all cards are in the DOM
    Object.entries(portfolio).forEach(([symbol, holding]) => {
        const actionsContainer = portfolioContainer.querySelector(`.stock-actions[data-symbol="${symbol}"]`);
        
        if (actionsContainer) {
            // Create buy button
            const buyButton = document.createElement('button');
            buyButton.className = 'action-button buy';
            buyButton.textContent = 'Buy';
            buyButton.style.pointerEvents = 'auto';
            buyButton.style.position = 'relative';
            buyButton.style.zIndex = '10';
            
            // Create sell button
            const sellButton = document.createElement('button');
            sellButton.className = 'action-button sell';
            sellButton.textContent = 'Sell';
            sellButton.style.pointerEvents = 'auto';
            sellButton.style.position = 'relative';
            sellButton.style.zIndex = '10';
            
            // Add buttons to container
            actionsContainer.appendChild(buyButton);
            actionsContainer.appendChild(sellButton);
            
            // Add event listeners with proper event prevention
            buyButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                promptTrade('buy', symbol, holding.name, holding.currentPrice || 0);
            });
            
            sellButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                promptTrade('sell', symbol, holding.name, holding.currentPrice || 0);
            });
        }
    });
    
    // Add click prevention to the card with search trigger
    document.querySelectorAll('.portfolio-card').forEach(card => {
      card.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          const symbol = card.getAttribute('data-symbol').replace('.NS', '');
          // Only trigger search if not already active
          if (activeSymbol !== symbol) {
              searchInput.value = symbol;
              manualSearch();
          }
      });
    });
    updatePortfolioStats();
  }
  
  function buyStock(symbol, name, price, quantity) {
    if (isIndex) {
      showNotification('Cannot trade indices', 'error');
      return;
    }
    if (isNaN(price) || price <= 0) {
      showNotification('Invalid price for buying', 'error');
      return;
    }
    const totalCost = price * quantity;
    if (totalCost > walletBalance) {
      showNotification('Insufficient wallet balance', 'error');
      return;
    }
    walletBalance -= totalCost;
    const normalizedSymbol = symbol.endsWith('.NS') ? symbol : `${symbol}.NS`;
    if (portfolio[normalizedSymbol]) {
      const existing = portfolio[normalizedSymbol];
      const totalQty = existing.quantity + quantity;
      const newAvgPrice = ((existing.avgPrice * existing.quantity) + (price * quantity)) / totalQty;
      portfolio[normalizedSymbol] = {
        ...existing,
        quantity: totalQty,
        avgPrice: newAvgPrice,
        currentPrice: price,
        volume: existing.volume || 0,
        dayHigh: existing.dayHigh || price,
        dayLow: existing.dayLow || price
      };
    } else {
      portfolio[normalizedSymbol] = {
        name,
        quantity,
        avgPrice: price,
        currentPrice: price,
        volume: 0,
        dayHigh: price,
        dayLow: price
      };
    }
    updateWalletBalance();
    renderPortfolio();
    showNotification(`Bought ${quantity} shares of ${name} at ₹${price.toLocaleString('en-IN', { maximumFractionDigits: 2 })}`, 'success');
    localStorage.setItem('portfolio', JSON.stringify(portfolio));
  }
  
  function sellStock(symbol, name, price, quantity) {
    if (isIndex) {
      showNotification('Cannot trade indices', 'error');
      return;
    }
    if (isNaN(price) || price <= 0) {
      showNotification('Invalid price for selling', 'error');
      return;
    }
    const normalizedSymbol = symbol.endsWith('.NS') ? symbol : `${symbol}.NS`;
    if (!portfolio[normalizedSymbol] || portfolio[normalizedSymbol].quantity < quantity) {
      showNotification('Insufficient shares to sell', 'error');
      return;
    }
    const totalEarned = price * quantity;
    walletBalance += totalEarned;
    portfolio[normalizedSymbol].quantity -= quantity;
    if (portfolio[normalizedSymbol].quantity === 0) {
      delete portfolio[normalizedSymbol];
    } else {
      portfolio[normalizedSymbol].currentPrice = price;
    }
    updateWalletBalance();
    renderPortfolio();
    showNotification(`Sold ${quantity} shares of ${name} at ₹${price.toLocaleString('en-IN', { maximumFractionDigits: 2 })}`, 'success');
    localStorage.setItem('portfolio', JSON.stringify(portfolio));
  }
  
  function promptTrade(action, symbol, name, price) {
    if (isIndex || !symbol || !name || isNaN(price) || price <= 0 || ['^NSEI', '^BSESN', '^NSEBANK', '^NSEMDCP50', 'BTCUSDT'].includes(symbol)) {
      showNotification('Cannot trade indices or invalid details', 'error');
      return;
    }
    const quantity = prompt(`Enter quantity to ${action} ${name}:`);
    if (quantity && !isNaN(quantity) && Number(quantity) > 0) {
      if (action === 'buy') {
        buyStock(symbol, name, price, Number(quantity));
      } else {
        sellStock(symbol, name, price, Number(quantity));
      }
    } else {
      showNotification('Invalid quantity entered', 'error');
    }
  }
  
  function showNotification(message, type = 'error') {
    notificationMessage.textContent = message;
    notificationMessage.className = `notification ${type === 'success' ? 'notification-success' : 'notification-error'}`;
    notificationMessage.classList.add('show');
    setTimeout(() => notificationMessage.classList.remove('show'), 5000);
  }
  
  function toggleTheme() {
    if (currentTheme === 'dark') {
      document.body.classList.remove('dark');
      document.body.classList.add('midnight');
      currentTheme = 'midnight';
    } else if (currentTheme === 'midnight') {
      document.body.classList.remove('midnight');
      document.body.classList.add('light');
      currentTheme = 'light';
    } else {
      document.body.classList.remove('light');
      document.body.classList.add('dark');
      currentTheme = 'dark';
    }
    const lightIcon = document.getElementById('lightIcon');
    const darkIcon = document.getElementById('darkIcon');
    if (currentTheme === 'dark' || currentTheme === 'midnight') {
      lightIcon.style.display = 'none';
      darkIcon.style.display = 'block';
    } else {
      lightIcon.style.display = 'block';
      darkIcon.style.display = 'none';
    }
    if (currentData && activeSymbol === currentData.symbol) {
      renderChart(currentData.name, currentData.historicalData, currentData.currentPrice, currentData.volume);
    }
  }
  
  function toggleHoldings() {
    if (portfolioSection.style.display === 'none' || portfolioSection.style.display === '') {
      portfolioSection.style.display = 'block';
      portfolioSection.classList.add('show');
      renderPortfolio();
      portfolioSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    } else {
      portfolioSection.style.display = 'none';
      portfolioSection.classList.remove('show');
    }
  }
  
  function isMarketOpen() {
    const now = new Date();
    const istOffset = 5.5 * 60 * 60 * 1000;
    const istTime = new Date(now.getTime() + istOffset);
    const marketOpen = new Date(istTime);
    marketOpen.setHours(9, 15, 0, 0);
    const marketClose = new Date(istTime);
    marketClose.setHours(15, 30, 0, 0);
    return istTime >= marketOpen && istTime <= marketClose;
  }
  
  function connectWebSocket() {
    let wsUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' ?
      'ws://localhost:3000' : 'wss://' + window.location.host;
    ws = new WebSocket(wsUrl);
  
    ws.onopen = () => {
      ws.send(JSON.stringify({ historical: '^NSEI', name: 'NIFTY 50' }));
    };
  
    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.indices && dataChanged(lastIndicesData, data.indices)) {
          data.indices.forEach(index => {
            indexData[index.symbol] = {
              name: index.name,
              price: index.price,
              lastClose: index.lastClose,
              percentChange: index.percentChange
            };
            if (activeSymbol === index.symbol && currentData) {
              currentData.currentPrice = index.price;
              updateChartEndPoint(currentData.name, currentData.historicalData, currentData.currentPrice, currentData.volume);
            }
          });
          updateIndices(data.indices);
          lastIndicesData = data.indices;
        }
  
        if (data.stocks && dataChanged(lastStocksData, data.stocks)) {
          data.stocks.forEach(stock => {
            const normalizedSymbol = stock.symbol.endsWith('.NS') ? stock.symbol : `${stock.symbol}.NS`;
            if (portfolio[normalizedSymbol] && stock.price && !isNaN(stock.price)) {
              portfolio[normalizedSymbol].currentPrice = stock.price;
              portfolio[normalizedSymbol].volume = stock.volume || 0;
              portfolio[normalizedSymbol].dayHigh = stock.dayHigh || stock.price;
              portfolio[normalizedSymbol].dayLow = stock.dayLow || stock.price;
            }
          });
          updateTopStocks(data.stocks);
          renderPortfolio();
          lastStocksData = data.stocks;
        }
  
        if ('searchResult' in data) {
          updateSearchResult(data.searchResult);
        }
  
        if ('historicalData' in data) {
          const symbol = data.historicalData.symbol;
          currentData = {
            symbol: symbol,
            name: data.historicalData.name,
            historicalData: data.historicalData.data,
            currentPrice: data.historicalData.currentPrice,
            volume: data.historicalData.volume || 0,
            dayHigh: data.historicalData.dayHigh || null,
            dayLow: data.historicalData.dayLow || null
          };
          indexData[symbol] = {
            ...indexData[symbol],
            price: data.historicalData.currentPrice,
            lastClose: data.historicalData.data.length > 1 ? 
              data.historicalData.data[data.historicalData.data.length - 2].close : 
              data.historicalData.currentPrice,
            percentChange: ((data.historicalData.currentPrice - 
              (data.historicalData.data.length > 1 ? 
                data.historicalData.data[data.historicalData.data.length - 2].close : 
                data.historicalData.currentPrice)) / 
              (data.historicalData.data.length > 1 ? 
                data.historicalData.data[data.historicalData.data.length - 2].close : 
                data.historicalData.currentPrice) * 100).toFixed(2)
          };
          if (activeSymbol === symbol) {
            renderChart(currentData.name, currentData.historicalData, currentData.currentPrice, currentData.volume);
            updateActiveButton(symbol);
          }
          updateIndices();
        }
  
        if ('priceUpdate' in data) {
          const symbol = data.priceUpdate.symbol;
          if (indexData[symbol]) {
            const lastClose = indexData[symbol].lastClose || 
              (currentData?.historicalData?.length > 1 ? 
                currentData.historicalData[currentData.historicalData.length - 2].close : 
                data.priceUpdate.price);
            indexData[symbol].price = data.priceUpdate.price;
            indexData[symbol].percentChange = ((data.priceUpdate.price - lastClose) / lastClose * 100).toFixed(2);
            const normalizedSymbol = symbol.endsWith('.NS') ? symbol : `${symbol}.NS`;
            if (portfolio[normalizedSymbol] && data.priceUpdate.price && !isNaN(data.priceUpdate.price)) {
              portfolio[normalizedSymbol].currentPrice = data.priceUpdate.price;
              portfolio[normalizedSymbol].volume = data.priceUpdate.volume || 0;
              portfolio[normalizedSymbol].dayHigh = data.priceUpdate.dayHigh || data.priceUpdate.price;
              portfolio[normalizedSymbol].dayLow = data.priceUpdate.dayLow || data.priceUpdate.price;
              renderPortfolio();
            }
            if (currentData && activeSymbol === symbol) {
              currentData.currentPrice = data.priceUpdate.price;
              currentData.volume = data.priceUpdate.volume || currentData.volume || 0;
              if (currentChartType === 'candlestick') {
                const lastCandle = currentData.historicalData[currentData.historicalData.length - 1] || {};
                const newCandle = {
                  date: data.priceUpdate.date || new Date().toISOString(),
                  open: lastCandle.close || data.priceUpdate.price,
                  high: Math.max(lastCandle.high || data.priceUpdate.price, data.priceUpdate.price),
                  low: Math.min(lastCandle.low || data.priceUpdate.price, data.priceUpdate.price),
                  close: data.priceUpdate.price,
                  volume: data.priceUpdate.volume || lastCandle.volume || 0
                };
                if (currentData.historicalData.length > 0 && 
                    new Date(lastCandle.date).getTime() === new Date(newCandle.date).getTime()) {
                  currentData.historicalData[currentData.historicalData.length - 1] = newCandle;
                } else {
                  currentData.historicalData.push(newCandle);
                  if (currentData.historicalData.length > 60) currentData.historicalData.shift();
                }
              } else {
                if (currentData.historicalData.length > 0) {
                  currentData.historicalData[currentData.historicalData.length - 1] = {
                    ...currentData.historicalData[currentData.historicalData.length - 1],
                    close: data.priceUpdate.price,
                    volume: data.priceUpdate.volume || currentData.volume || 0
                  };
                }
              }
              updateChartEndPoint(currentData.name, currentData.historicalData, currentData.currentPrice, currentData.volume);
            }
          }
          updateIndices();
        }
  
        if (data.news && (!lastNewsData || JSON.stringify(data.news) !== JSON.stringify(lastNewsData))) {
          updateNews(data.news);
          lastNewsData = data.news;
        }
  
        if (data.losers && dataChanged(lastLosersData, data.losers)) {
          data.losers.forEach(stock => {
            const normalizedSymbol = stock.symbol.endsWith('.NS') ? stock.symbol : `${stock.symbol}.NS`;
            if (portfolio[normalizedSymbol] && stock.price && !isNaN(stock.price)) {
              portfolio[normalizedSymbol].currentPrice = stock.price;
              portfolio[normalizedSymbol].volume = stock.volume || 0;
              portfolio[normalizedSymbol].dayHigh = stock.dayHigh || stock.price;
              portfolio[normalizedSymbol].dayLow = stock.dayLow || stock.price;
            }
          });
          updateLosers(data.losers);
          renderPortfolio();
          lastLosersData = data.losers;
        }
  
        if (data.predictions && dataChanged(lastPredictionsData, data.predictions)) {
          data.predictions.forEach(stock => {
            const normalizedSymbol = stock.symbol.endsWith('.NS') ? stock.symbol : `${stock.symbol}.NS`;
            if (portfolio[normalizedSymbol] && stock.price && !isNaN(stock.price)) {
              portfolio[normalizedSymbol].currentPrice = stock.price;
              portfolio[normalizedSymbol].volume = stock.volume || 0;
              portfolio[normalizedSymbol].dayHigh = stock.dayHigh || stock.price;
              portfolio[normalizedSymbol].dayLow = stock.dayLow || stock.price;
            }
          });
          updatePredictions(data.predictions);
          renderPortfolio();
          lastPredictionsData = data.predictions;
        } else {
          generateDailyPredictions();
        }
  
        if (data.error) {
          showNotification(`Error: ${data.error}`, 'error');
        }
      } catch (err) {
        console.error('Error parsing local WebSocket message:', err);
        showNotification('Client-side error: Failed to process data', 'error');
      }
    };
  
    ws.onerror = (error) => {
      console.error('Local WebSocket error:', error);
      showNotification('Local WebSocket connection error', 'error');
    };
  
    ws.onclose = () => {
      console.log('Local WebSocket closed');
      showNotification('Local WebSocket connection closed. Reconnecting...', 'error');
      setTimeout(connectWebSocket, 2000);
    };
  }
  
  function dataChanged(oldData, newData) {
    if (!oldData || !newData || oldData.length !== newData.length) return true;
    return oldData.some((item, idx) => 
      item.price !== newData[idx].price || 
      item.lastClose !== newData[idx].lastClose || 
      item.percentChange !== newData[idx].percentChange || 
      item.name !== newData[idx].name || 
      item.symbol !== newData[idx].symbol ||
      (item.percentDrop !== undefined && item.percentDrop !== newData[idx].percentDrop) ||
      (item.predictedGain !== undefined && item.predictedGain !== newData[idx].predictedGain)
    );
  }
  
  function connectBinanceWebSocket() {
    binanceWs = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@kline_1m');
    binanceWs.onopen = () => console.log('Binance WebSocket connected');
    binanceWs.onmessage = (event) => {
      const data = JSON.parse(event.data);
      const kline = data.k;
      if (!kline) return;
  
      const historicalData = currentData && currentData.symbol === 'BTCUSDT' ? currentData.historicalData : [];
      const newCandle = {
        date: new Date(kline.t).toISOString(),
        open: parseFloat(kline.o),
        high: parseFloat(kline.h),
        low: parseFloat(kline.l),
        close: parseFloat(kline.c),
        volume: parseFloat(kline.v)
      };
  
      if (historicalData.length === 0 || new Date(historicalData[historicalData.length - 1].date).getTime() < kline.t) {
        historicalData.push(newCandle);
        if (historicalData.length > 60) historicalData.shift();
      } else {
        historicalData[historicalData.length - 1] = newCandle;
      }
  
      if (currentSymbol === 'BTCUSDT') {
        currentData = {
          symbol: 'BTCUSDT',
          name: 'Bitcoin (BTC/USDT)',
          historicalData: historicalData,
          currentPrice: parseFloat(kline.c),
          volume: parseFloat(kline.v)
        };
        if (activeSymbol === 'BTCUSDT') {
          updateChartEndPoint(currentData.name, currentData.historicalData, currentData.currentPrice, currentData.volume);
        }
      }
  
      const lastClose = indexData['BTCUSDT'].lastClose || (currentData?.historicalData?.length > 1 ? currentData.historicalData[currentData.historicalData.length - 2].close : parseFloat(kline.c));
      indexData['BTCUSDT'].price = parseFloat(kline.c);
      indexData['BTCUSDT'].volume = parseFloat(kline.v);
      indexData['BTCUSDT'].percentChange = ((parseFloat(kline.c) - lastClose) / lastClose * 100).toFixed(2);
      if (currentData && currentSymbol === 'BTCUSDT') {
        currentData.currentPrice = parseFloat(kline.c);
        currentData.volume = parseFloat(kline.v);
        updateChartEndPoint(currentData.name, currentData.historicalData, currentData.currentPrice, currentData.volume);
      }
      updateIndices();
    };
    binanceWs.onerror = (error) => {
      console.error('Binance WebSocket error:', error);
      showNotification('Binance WebSocket connection error', 'error');
    };
    binanceWs.onclose = () => {
      console.log('Binance WebSocket closed');
      showNotification('Binance WebSocket connection closed. Reconnecting...', 'error');
      setTimeout(connectBinanceWebSocket, 2000);
    };
  }
  
  connectWebSocket();
  connectBinanceWebSocket();
  
  function updateActiveButton(symbol) {
    const buttons = document.querySelectorAll('.index-button');
    buttons.forEach(button => {
      button.classList.remove('active');
      if (symbol && button.getAttribute('onclick').includes(`'${symbol}'`)) {
        button.classList.add('active');
      }
    });
  }
  
  function updateIndices(indices) {
    if (!Array.isArray(indices)) indices = [];
    const desiredIndices = [
      { symbol: '^NSEI', name: 'NIFTY 50' },
      { symbol: '^BSESN', name: 'SENSEX' },
      { symbol: '^NSEBANK', name: 'BANK NIFTY' },
      { symbol: '^NSEMDCP50', name: 'NIFTY MIDCAP 50' },
      { symbol: 'BTCUSDT', name: 'Bitcoin (BTC/USDT)' }
    ];
  
    desiredIndices.forEach((desiredIndex, idx) => {
      const index = {
        symbol: desiredIndex.symbol,
        name: desiredIndex.name,
        price: indexData[desiredIndex.symbol]?.price || (indices.find(i => i.symbol === desiredIndex.symbol)?.price || null),
        lastClose: indexData[desiredIndex.symbol]?.lastClose || (indices.find(i => i.symbol === desiredIndex.symbol)?.lastClose || null),
        percentChange: indexData[desiredIndex.symbol]?.percentChange || (indices.find(i => i.symbol === desiredIndex.symbol)?.percentChange || null)
      };
  
      const isBitcoin = index.symbol === 'BTCUSDT';
      const price = index.price && !isNaN(index.price) ? 
        (isBitcoin ? `$${Number(index.price).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : `₹${Number(index.price).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
      const lastClose = index.lastClose && !isNaN(index.lastClose) ? 
        (isBitcoin ? `$${Number(index.lastClose).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : `₹${Number(index.lastClose).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
      const percentChange = index.percentChange && !isNaN(index.percentChange) ? `${index.percentChange >= 0 ? '+' : ''}${Number(index.percentChange).toFixed(2)}%` : 'N/A';
  
      let card = document.getElementById(`index-${index.symbol}`);
      if (!card) {
        card = document.createElement('div');
        card.id = `index-${index.symbol}`;
        card.className = 'price-card';
        card.style.animationDelay = `${0.3 + (idx * 0.05)}s`;
        card.innerHTML = `
        <div>
          <h3 class="asset-name">${index.name}</h3>
          <p class="last-close">Last Close: ${lastClose}</p>
        </div>
        <div class="price-display">
          <p class="current-price ${price === 'N/A' ? 'unavailable' : 'available'}">Price: ${price}</p>
          <p class="stock-change ${percentChange === 'N/A' ? '' : (index.percentChange >= 0 ? 'positive' : 'negative')}">${percentChange}</p>
        </div>
      `;
        card.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          isBitcoin ? toggleBitcoinData(index.symbol, index.name) : toggleHistoricalData(index.symbol, index.name);
        });
        stockCards.appendChild(card);
      } else {
        const priceEl = card.querySelector('.current-price');
        const changeEl = card.querySelector('.stock-change');
        if (priceEl.textContent !== `Price: ${price}`) priceEl.textContent = `Price: ${price}`;
        if (changeEl.textContent !== percentChange) changeEl.textContent = percentChange;
        changeEl.className = `stock-change ${percentChange === 'N/A' ? '' : (index.percentChange >= 0 ? 'positive' : 'negative')}`;
      }
    });
  }
  
  function updateTopStocks(stocks) {
    if (!Array.isArray(stocks)) return;

    stocks.forEach((stock, idx) => {
        if (!stock || !stock.symbol || !stock.name) return;

        const price = stock.price && !isNaN(stock.price) ? `₹${Number(stock.price).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';
        const volume = stock.volume && !isNaN(stock.volume) ? Number(stock.volume).toLocaleString('en-IN') : '0';
        const percentChange = stock.percentChange && !isNaN(stock.percentChange) ? `${stock.percentChange >= 0 ? '+' : ''}${Number(stock.percentChange).toFixed(2)}%` : 'N/A';
        const dayLow = stock.dayLow && !isNaN(stock.dayLow) ? `₹${Number(stock.dayLow).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';
        const dayHigh = stock.dayHigh && !isNaN(stock.dayHigh) ? `₹${Number(stock.dayHigh).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';

        let card = document.getElementById(`stock-${stock.symbol}`);
        if (!card) {
            card = document.createElement('div');
            card.id = `stock-${stock.symbol}`;
            card.className = 'top-stock-card';
            card.style.animationDelay = `${0.2 + (idx * 0.05)}s`;
            card.innerHTML = `
                <div class="stock-info">
                    <h3 class="stock-name">${stock.name}</h3>
                    <p class="stock-price">Price: <span>${price}</span></p>
                    <p class="day-low">Day Low: <span>${dayLow}</span></p>
                    <p class="day-high">Day High: <span>${dayHigh}</span></p>
                    <p class="volume">Volume: <span>${volume}</span></p>
                    <p class="stock-change ${percentChange === 'N/A' ? '' : (stock.percentChange >= 0 ? 'positive' : 'negative')}"><span>${percentChange}</span></p>
                    <div class="stock-actions">
                        <button class="action-button buy" onclick="promptTrade('buy', '${stock.symbol}', '${stock.name.replace(/'/g, "\\'")}', ${stock.price || 0})">Buy</button>
                        <button class="action-button sell" onclick="promptTrade('sell', '${stock.symbol}', '${stock.name.replace(/'/g, "\\'")}', ${stock.price || 0})">Sell</button>
                    </div>
                </div>
            `;
            card.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!e.target.classList.contains('action-button')) {
                    // Only trigger search if not already active
                    if (activeSymbol !== stock.symbol) {
                        searchInput.value = stock.symbol;
                        manualSearch();
                    }
                }
            });
            topStocksContainer.appendChild(card);
        } else {
            const priceSpan = card.querySelector('.stock-price span');
            const dayLowSpan = card.querySelector('.day-low span');
            const dayHighSpan = card.querySelector('.day-high span');
            const volumeSpan = card.querySelector('.volume span');
            const changeSpan = card.querySelector('.stock-change span');
            if (priceSpan.textContent !== price) priceSpan.textContent = price;
            if (dayLowSpan.textContent !== dayLow) dayLowSpan.textContent = dayLow;
            if (dayHighSpan.textContent !== dayHigh) dayHighSpan.textContent = dayHigh;
            if (volumeSpan.textContent !== volume) volumeSpan.textContent = volume;
            if (changeSpan.textContent !== percentChange) changeSpan.textContent = percentChange;
            changeSpan.className = `stock-change ${percentChange === 'N/A' ? '' : (stock.percentChange >= 0 ? 'positive' : 'negative')}`;
        }
    });
}
  
  function generateDailyPredictions() {
    const today = new Date().toDateString();
    if (currentPredictionDate !== today) {
      currentPredictionDate = today;
      const stockPool = [
        { symbol: 'RELIANCE', name: 'Reliance Industries' },
        { symbol: 'TCS', name: 'Tata Consultancy Services' },
        { symbol: 'HDFCBANK', name: 'HDFC Bank' },
        { symbol: 'INFY', name: 'Infosys' },
        { symbol: 'ICICIBANK', name: 'ICICI Bank' },
        { symbol: 'SBIN', name: 'State Bank of India' },
        { symbol: 'HINDUNILVR', name: 'Hindustan Unilever' },
        { symbol: 'BHARTIARTL', name: 'Bharti Airtel' },
        { symbol: 'ITC', name: 'ITC Limited' },
        { symbol: 'LT', name: 'Larsen & Toubro' },
        { symbol: 'ASIANPAINT', name: 'Asian Paints' },
        { symbol: 'AXISBANK', name: 'Axis Bank' },
        { symbol: 'MARUTI', name: 'Maruti Suzuki' },
        { symbol: 'KOTAKBANK', name: 'Kotak Mahindra Bank' },
        { symbol: 'SUNPHARMA', name: 'Sun Pharmaceutical' }
      ];
  
      // Shuffle and select 10 stocks
      const shuffled = stockPool.sort(() => 0.5 - Math.random());
      const selectedStocks = shuffled.slice(0, 10).map(stock => {
        const price = (Math.random() * 2000 + 500).toFixed(2); // Random price between ₹500 and ₹2500
        const dayHigh = (Math.random() * 2200 + 550).toFixed(2); // Random high between ₹550 and ₹2750
        const dayLow = (Math.random() * 1800 + 450).toFixed(2); // Random low between ₹450 and ₹2250
  
        return {
          symbol: stock.symbol,
          name: stock.name,
          price: price,
          predictedGain: (Math.random() * 10 + 2).toFixed(2), // Random gain between 2% and 12%
          volume: Math.floor(Math.random() * 1000000 + 100000), // Random volume between 100,000 and 1,100,000
          dayHigh: Math.max(parseFloat(dayHigh), parseFloat(dayLow)).toFixed(2), // Ensure dayHigh >= dayLow
          dayLow: Math.min(parseFloat(dayHigh), parseFloat(dayLow)).toFixed(2), // Ensure dayLow <= dayHigh
          // Ensure price is between dayLow and dayHigh
          adjustedPrice: Math.max(
            parseFloat(dayLow),
            Math.min(parseFloat(dayHigh), parseFloat(price))
          ).toFixed(2)
        };
      }).map(stock => ({
        // Replace price with adjustedPrice and clean up
        symbol: stock.symbol,
        name: stock.name,
        price: stock.adjustedPrice,
        predictedGain: stock.predictedGain,
        volume: stock.volume,
        dayHigh: stock.dayHigh,
        dayLow: stock.dayLow
      }));
  
      lastPredictionsData = selectedStocks;
      updatePredictions(selectedStocks);
    } else {
      updatePredictions(lastPredictionsData);
    }
  }
  function updatePredictions(predictions) {
    if (!Array.isArray(predictions)) {
      generateDailyPredictions();
      return;
    }
  
    const predictionsContainer = document.getElementById('predictionsContainer');
    predictionsContainer.innerHTML = '';
  
    const displayPredictions = predictions.length >= 10 ? predictions.slice(0, 10) : predictions;
    displayPredictions.forEach((stock, idx) => {
      if (!stock || !stock.symbol || !stock.name || !stock.price) return;
  
      const price = stock.price && !isNaN(stock.price) ? 
        `₹${Number(stock.price).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';
      const predictedGain = stock.predictedGain && !isNaN(stock.predictedGain) ? 
        `+${Number(stock.predictedGain).toFixed(2)}%` : 'N/A';
      const volume = stock.volume && !isNaN(stock.volume) ? 
        Number(stock.volume).toLocaleString('en-IN') : '0';
  
      const card = document.createElement('div');
      card.id = `prediction-${stock.symbol}`;
      card.className = 'prediction-card';
      card.style.animationDelay = `${0.1 + (idx * 0.05)}s`;
      card.innerHTML = `
        <div class="prediction-info">
          <h3 class="prediction-name">${stock.name}</h3>
          <p class="prediction-price ${price === 'N/A' ? 'unavailable' : 'available'}">Current Price: ${price}</p>
          <p class="prediction-gain">Predicted Gain: ${predictedGain}</p>
          <p class="volume">Volume: ${volume}</p>
          <div class="stock-actions">
            <button class="action-button buy" onclick="promptTrade('buy', '${stock.symbol}', '${stock.name.replace(/'/g, "\\'")}', ${stock.price || 0})">Buy</button>
            <button class="action-button sell" onclick="promptTrade('sell', '${stock.symbol}', '${stock.name.replace(/'/g, "\\'")}', ${stock.price || 0})">Sell</button>
          </div>
        </div>
      `;
      card.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!e.target.classList.contains('action-button')) {
          searchInput.value = stock.symbol;
          manualSearch();
        }
      });
      predictionsContainer.appendChild(card);
    });
  }
  
  function updateLosers(losers) {
    if (!Array.isArray(losers)) return;
  
    const losersContainer = document.getElementById('losersContainer');
    losersContainer.innerHTML = '';
  
    losers.forEach((stock, idx) => {
      if (!stock || !stock.symbol || !stock.name || !stock.price) return;
  
      const price = stock.price && !isNaN(stock.price) ? 
        `₹${Number(stock.price).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';
      const volume = stock.volume && !isNaN(stock.volume) ? 
        Number(stock.volume).toLocaleString('en-IN') : '0';
      const percentDrop = stock.percentDrop && !isNaN(stock.percentDrop) ? 
        `${Number(stock.percentDrop).toFixed(2)}%` : 'N/A';
  
      const card = document.createElement('div');
      card.id = `loser-${stock.symbol}`;
      card.className = 'loser-card';
      card.style.animationDelay = `${0.1 + (idx * 0.05)}s`;
      card.innerHTML = `
        <div class="loser-info">
          <h3 class="loser-name">${stock.name}</h3>
          <p class="loser-price">Price: ${price}</p>
          <p class="volume">Volume: ${volume}</p>
          <p class="loser-drop">Drop: -${percentDrop}</p>
          <div class="stock-actions">
            <button class="action-button buy" onclick="promptTrade('buy', '${stock.symbol}', '${stock.name.replace(/'/g, "\\'")}', ${stock.price || 0})">Buy</button>
            <button class="action-button sell" onclick="promptTrade('sell', '${stock.symbol}', '${stock.name.replace(/'/g, "\\'")}', ${stock.price || 0})">Sell</button>
          </div>
        </div>
      `;
      card.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!e.target.classList.contains('action-button')) {
          searchInput.value = stock.symbol;
          manualSearch();
        }
      });
      losersContainer.appendChild(card);
    });
  }
  
  function updateSearchResult(result) {
    if (result === null) {
        searchResult.classList.remove('show');
        if (activeSymbol === null) {
            chartContainer.classList.remove('show');
            if (stockChart) stockChart.destroy();
            priceInfo.innerHTML = '';
        }
    } else if (result.error) {
        searchResult.innerHTML = `<p>${result.error}</p>`;
        searchResult.classList.add('error', 'show');
    } else {
        const price = result.price && !isNaN(result.price) ? `₹${Number(result.price).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';
        const volume = result.volume && !isNaN(result.volume) ? Number(result.volume).toLocaleString('en-IN') : '0';
        const dayHigh = result.dayHigh && !isNaN(result.dayHigh) ? `₹${Number(result.dayHigh).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';
        const dayLow = result.dayLow && !isNaN(result.dayLow) ? `₹${Number(result.dayLow).toLocaleString('en-IN', { maximumFractionDigits: 2 })}` : 'N/A';
        let percentChange = result.percentChange && !isNaN(result.percentChange) ? 
            `${result.percentChange >= 0 ? '+' : ''}${Number(result.percentChange).toFixed(2)}%` : 'N/A';

        if (percentChange === 'N/A' && result.historicalData && result.historicalData.length > 1) {
            const lastClose = result.historicalData[result.historicalData.length - 2].close;
            if (lastClose && result.price && lastClose !== 0 && result.lastClose !== result.price) {
                percentChange = (((result.price - lastClose) / lastClose) * 100).toFixed(2);
                percentChange = `${percentChange >= 0 ? '+' : ''}${percentChange}%`;
            }
        } else if (percentChange === 'N/A' && result.lastClose && result.price && result.lastClose !== 0 && result.lastClose !== result.price) {
            percentChange = (((result.price - result.lastClose) / result.lastClose) * 100).toFixed(2);
            percentChange = `${percentChange >= 0 ? '+' : ''}${percentChange}%`;
        }

        if (isIndex && currentSymbol && indexData[currentSymbol] && indexData[currentSymbol].percentChange !== undefined) {
            percentChange = `${indexData[currentSymbol].percentChange >= 0 ? '+' : ''}${Number(indexData[currentSymbol].percentChange).toFixed(2)}%`;
        }

        searchResult.classList.remove('error');
        searchResult.classList.add('show');

        // Only update if the symbol has changed to prevent redundant rendering
        if (result.historicalData && currentSymbol !== result.symbol) {
            currentSymbol = result.symbol;
            activeSymbol = currentSymbol;
            isIndex = result.symbol.startsWith('^') || result.symbol === 'BTCUSDT';
            currentData = {
                symbol: result.symbol,
                name: result.name || 'Unknown',
                historicalData: result.historicalData,
                currentPrice: result.price,
                volume: result.volume || 0,
                dayHigh: result.dayHigh || result.price, // Ensure dayHigh is set
                dayLow: result.dayLow || result.price   // Ensure dayLow is set
            };
            renderChart(currentData.name, currentData.historicalData, currentData.currentPrice, currentData.volume);
            updateActiveButton(null);
        }

        searchResult.innerHTML = `
            <h3>${result.name}</h3>
            <p>Price: ${price}</p>
            <p>Volume: ${volume}</p>
            <p>Day High: ${dayHigh}</p>
            <p>Day Low: ${dayLow}</p>
            <p class="${percentChange === 'N/A' ? '' : (percentChange.includes('-') ? 'negative' : 'positive')}">Change: ${percentChange}</p>
        `;
    }
}
  function toggleHistoricalData(symbol, name) {
    if (activeSymbol === symbol) {
      activeSymbol = null;
      chartContainer.classList.remove('show');
      if (stockChart) stockChart.destroy();
      priceInfo.innerHTML = '';
      currentSymbol = null;
      currentData = null;
      updateActiveButton(null);
    } else {
      activeSymbol = symbol;
      currentSymbol = symbol;
      isIndex = true;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ historical: symbol, name }));
      } else {
        showNotification('WebSocket is not connected. Please try again later.', 'error');
      }
      updateActiveButton(symbol);
    }
  }
  
  function toggleBitcoinData(symbol, name) {
    if (activeSymbol === symbol) {
      activeSymbol = null;
      chartContainer.classList.remove('show');
      if (stockChart) stockChart.destroy();
      priceInfo.innerHTML = '';
      currentSymbol = null;
      currentData = null;
      updateActiveButton(null);
    } else {
      activeSymbol = symbol;
      currentSymbol = symbol;
      isIndex = true;
      if (!currentData || currentData.symbol !== 'BTCUSDT') {
        currentData = {
          symbol: 'BTCUSDT',
          name: 'Bitcoin (BTC/USDT)',
          historicalData: [],
          currentPrice: null,
          volume: 0
        };
      }
      renderChart(currentData.name, currentData.historicalData, currentData.currentPrice, currentData.volume);
      updateActiveButton(symbol);
    }
  }
  
  function renderChart(name, historicalData, currentPrice, volume) {
    if (stockChart) stockChart.destroy();
    chartContainer.classList.add('show');
    const ctx = document.getElementById('stockChart').getContext('2d');
    
    const isBitcoin = name === 'Bitcoin (BTC/USDT)';
    const formattedCurrentPrice = currentPrice && !isNaN(currentPrice) ? 
        (isBitcoin ? `$${Number(currentPrice).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : 
        `₹${Number(currentPrice).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
    const lastClosingPrice = historicalData.length > 1 ? 
        historicalData[historicalData.length - 2].close : 
        (historicalData.length > 0 ? historicalData[historicalData.length - 1].close : 'N/A');
    const formattedLastClose = lastClosingPrice && !isNaN(lastClosingPrice) ? 
        (isBitcoin ? `$${Number(lastClosingPrice).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : 
        `₹${Number(lastClosingPrice).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
    let percentChange = indexData[currentSymbol]?.percentChange || 
        (lastClosingPrice !== 'N/A' && currentPrice !== 'N/A' && lastClosingPrice !== 0 ? 
            ((currentPrice - lastClosingPrice) / lastClosingPrice * 100) : 'N/A');
    const displayPercentChange = percentChange !== 'N/A' ? 
        `${percentChange >= 0 ? '+' : ''}${Number(percentChange).toFixed(2)}%` : 'N/A';
    const changeClass = percentChange !== 'N/A' ? 
        (percentChange < 0 ? 'stock-change negative' : 'stock-change positive') : 'stock-change';

    const formattedDayHigh = currentData.dayHigh && !isNaN(currentData.dayHigh) ? 
        (isBitcoin ? `$${Number(currentData.dayHigh).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : 
        `₹${Number(currentData.dayHigh).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
    const formattedDayLow = currentData.dayLow && !isNaN(currentData.dayLow) ? 
        (isBitcoin ? `$${Number(currentData.dayLow).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : 
        `₹${Number(currentData.dayLow).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
    const formattedVolume = volume && !isNaN(volume) ? Number(volume).toLocaleString('en-IN') : 'N/A';

    let actionsHtml = '';
    if (!isIndex && currentPrice && !isNaN(currentPrice) && currentSymbol && name && !['^NSEI', '^BSESN', '^NSEBANK', '^NSEMDCP50', 'BTCUSDT'].includes(currentSymbol)) {
        actionsHtml = `
            <div class="stock-actions">
                <button class="action-button buy" onclick="promptTrade('buy', '${currentSymbol}', '${name.replace(/'/g, "\\'")}', ${currentPrice})">Buy</button>
                <button class="action-button sell" onclick="promptTrade('sell', '${currentSymbol}', '${name.replace(/'/g, "\\'")}', ${currentPrice})">Sell</button>
            </div>
        `;
    }

    priceInfo.innerHTML = `
    <p class="${formattedCurrentPrice === 'N/A' ? 'unavailable' : 'available'}">Price: ${formattedCurrentPrice}</p>
    <p class="last-close">Last Close: ${formattedLastClose}</p>
    <p class="${changeClass}">${displayPercentChange}</p>
    <p class="day-high">Day High: ${formattedDayHigh}</p>
    <p class="day-low">Day Low: ${formattedDayLow}</p>
    ${actionsHtml}
  `;
    
    const percentElement = document.querySelector('#priceInfo .stock-change');
    if (percentElement && percentChange < 0) {
        percentElement.style.color = '#FF3333';
    }

    // Theme configuration (unchanged)
    const themes = {
        light: {
            backgroundColor: '#F9FAFB',
            gradientStart: '#F3F4F6',
            gradientEnd: '#E5E7EB',
            lineColor: '#3B82F6',
            lineFill: 'rgba(59, 130, 246, 0.3)',
            currentPriceLine: '#9333EA',
            textColor: '#374151',
            gridColor: 'rgba(229, 231, 235, 0.5)'
        },
        dark: {
            backgroundColor: '#1F2A44',
            gradientStart: '#2D3748',
            gradientEnd: '#1A202C',
            lineColor: '#00E5D8',
            lineFill: 'rgba(0, 229, 216, 0.3)',
            currentPriceLine: '#FF4444',
            textColor: '#9CA3AF',
            gridColor: 'rgba(55, 65, 81, 0.5)'
        },
        midnight: {
            backgroundColor: '#1A2344',
            gradientStart: '#2D3748',
            gradientEnd: '#151A2E',
            lineColor: '#00E5D8',
            lineFill: 'rgba(0, 229, 216, 0.3)',
            currentPriceLine: '#FF4444',
            textColor: '#A0AECB',
            gridColor: 'rgba(45, 55, 72, 0.5)'
        }
    };
    
    const theme = themes[currentTheme];
    const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
    gradient.addColorStop(0, theme.gradientStart);
    gradient.addColorStop(1, theme.gradientEnd);
    ctx.canvas.style.background = gradient;

    const currentPriceAnnotation = {
        type: 'line',
        yMin: currentPrice,
        yMax: currentPrice,
        borderColor: theme.currentPriceLine,
        borderWidth: 2,
        borderDash: [5, 5],
        label: {
            content: `Current: ${formattedCurrentPrice}`,
            enabled: true,
            position: 'end',
            backgroundColor: theme.currentPriceLine,
            color: '#fff',
            font: { size: 12, family: "'Inter', sans-serif" },
            padding: 6,
            cornerRadius: 6
        }
    };

    if (currentChartType === 'line') {
        const prices = historicalData.map(d => d.close);
        const lineGradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
        lineGradient.addColorStop(0, theme.lineFill);
        lineGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        stockChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: Array(historicalData.length).fill(''),
                datasets: [{
                    label: `${name} - Price`,
                    data: prices,
                    borderColor: theme.lineColor,
                    borderWidth: 2.5,
                    fill: true,
                    backgroundColor: lineGradient,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    pointBackgroundColor: theme.lineColor,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 500, easing: 'easeOutQuad' },
                plugins: {
                    legend: { display: false },
                    title: {
                        display: true,
                        text: name,
                        color: theme.textColor,
                        font: { size: 22, family: "'Inter', sans-serif", weight: "700" },
                        padding: { top: 12, bottom: 24 }
                    },
                    tooltip: {
                        backgroundColor: theme.backgroundColor,
                        titleColor: theme.textColor,
                        bodyColor: theme.textColor,
                        borderColor: theme.gridColor,
                        borderWidth: 1,
                        padding: 12,
                        cornerRadius: 10,
                        callbacks: {
                            label: (context) => `Price: ${isBitcoin ? '$' : '₹'}${context.parsed.y.toLocaleString(isBitcoin ? 'en-US' : 'en-IN', { maximumFractionDigits: 2 })}`
                        }
                    },
                    annotation: {
                        annotations: {
                            currentPriceLine: currentPriceAnnotation
                        }
                    }
                },
                scales: {
                    x: { display: false },
                    y: {
                        title: { display: true, text: `Price (${isBitcoin ? '$' : '₹'})`, color: theme.textColor, font: { size: 14 } },
                        ticks: { color: theme.textColor, callback: (value) => `${isBitcoin ? '$' : '₹'}${value.toLocaleString(isBitcoin ? 'en-US' : 'en-IN', { maximumFractionDigits: 2 })}` },
                        grid: { color: theme.gridColor, borderDash: [6, 6] }
                    }
                }
            }
        });
    } else {
        const candlestickData = historicalData.map(d => ({
            x: new Date(d.date).getTime(),
            o: parseFloat(d.open),
            h: parseFloat(d.high),
            l: parseFloat(d.low),
            c: parseFloat(d.close),
            v: parseFloat(d.volume || 0)
        }));

        stockChart = new Chart(ctx, {
            type: 'candlestick',
            data: {
                datasets: [{
                    label: `${name} - Candlestick`,
                    data: candlestickData,
                    color: {
                        up: '#10B981',
                        down: '#EF4444',
                        unchanged: theme.textColor
                    },
                    borderColor: {
                        up: '#059669',
                        down: '#DC2626',
                        unchanged: theme.borderColor
                    },
                    barThickness: 'flex',
                    barPercentage: 0.8,
                    categoryPercentage: 0.9,
                    wickThickness: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 300, easing: 'easeOutQuad' },
                plugins: {
                    legend: { display: false },
                    title: {
                        display: true,
                        text: name,
                        color: theme.textColor,
                        font: { size: 22, family: "'Inter', sans-serif", weight: "700" },
                        padding: { top: 12, bottom: 24 }
                    },
                    tooltip: {
                        backgroundColor: theme.backgroundColor,
                        titleColor: theme.textColor,
                        bodyColor: theme.textColor,
                        borderColor: theme.borderColor,
                        borderWidth: 1,
                        padding: 12,
                        cornerRadius: 10,
                        callbacks: {
                            label: (context) => {
                                const data = context.raw;
                                return [
                                    `Open: ${isBitcoin ? '$' : '₹'}${data.o.toLocaleString(isBitcoin ? 'en-US' : 'en-IN', { maximumFractionDigits: 2 })}`,
                                    `High: ${isBitcoin ? '$' : '₹'}${data.h.toLocaleString(isBitcoin ? 'en-US' : 'en-IN', { maximumFractionDigits: 2 })}`,
                                    `Low: ${isBitcoin ? '$' : '₹'}${data.l.toLocaleString(isBitcoin ? 'en-US' : 'en-IN', { maximumFractionDigits: 2 })}`,
                                    `Close: ${isBitcoin ? '$' : '₹'}${data.c.toLocaleString(isBitcoin ? 'en-US' : 'en-IN', { maximumFractionDigits: 2 })}`,
                                    `Volume: ${data.v.toLocaleString('en-IN')}`
                                ];
                            }
                        }
                    },
                    annotation: {
                        annotations: {
                            currentPriceLine: currentPriceAnnotation
                        }
                    }
                },
                scales: {
                    x: { 
                        type: 'time',
                        time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
                        ticks: { color: theme.textColor, source: 'data', maxRotation: 0 },
                        grid: { display: false }
                    },
                    y: {
                        title: { display: true, text: `Price (${isBitcoin ? '$' : '₹'})`, color: theme.textColor, font: { size: 14 } },
                        ticks: { color: theme.textColor, callback: (value) => `${isBitcoin ? '$' : '₹'}${value.toLocaleString(isBitcoin ? 'en-US' : 'en-IN', { maximumFractionDigits: 2 })}` },
                        grid: { color: theme.gridColor, borderDash: [6, 6] }
                    }
                }
            }
        });
    }
}
  
  function updateChartEndPoint(name, historicalData, currentPrice, volume) {
    if (!stockChart || !currentData || !historicalData || historicalData.length === 0) return;
  
    const isBitcoin = name === 'Bitcoin (BTC/USDT)';
    const formattedCurrentPrice = currentPrice && !isNaN(currentPrice) ? 
      (isBitcoin ? `$${Number(currentPrice).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : 
      `₹${Number(currentPrice).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
    const themes = {
      light: { currentPriceLine: '#9333EA' },
      dark: { currentPriceLine: '#FF4444' },
      midnight: { currentPriceLine: '#FF4444' }
    };
    const theme = themes[currentTheme];
  
    // Update current price annotation
    stockChart.options.plugins.annotation.annotations.currentPriceLine = {
      type: 'line',
      yMin: currentPrice,
      yMax: currentPrice,
      borderColor: theme.currentPriceLine,
      borderWidth: 2,
      borderDash: [5, 5],
      label: {
        content: `Current: ${formattedCurrentPrice}`,
        enabled: true,
        position: 'end',
        backgroundColor: theme.currentPriceLine,
        color: '#fff',
        font: { size: 12, family: "'Inter', sans-serif" },
        padding: 6,
        cornerRadius: 6
      }
    };
  
    if (currentChartType === 'line') {
      stockChart.data.datasets[0].data = historicalData.map(d => d.close);
      stockChart.data.labels = Array(historicalData.length).fill('');
      stockChart.update('none');
    } else {
      const lastCandle = historicalData[historicalData.length - 1] || {};
      const newCandle = {
        x: new Date(lastCandle.date || new Date()).getTime(),
        o: lastCandle.open || currentPrice,
        h: Math.max(lastCandle.high || currentPrice, currentPrice),
        l: Math.min(lastCandle.low || currentPrice, currentPrice),
        c: currentPrice,
        v: volume || lastCandle.volume || 0
      };
      stockChart.data.datasets[0].data = historicalData.map(d => ({
        x: new Date(d.date).getTime(),
        o: parseFloat(d.open),
        h: parseFloat(d.high),
        l: parseFloat(d.low),
        c: parseFloat(d.close),
        v: parseFloat(d.volume || 0)
      }));
      stockChart.data.datasets[0].data[stockChart.data.datasets[0].data.length - 1] = newCandle;
      stockChart.update('none');
    }
  
    // Update price info
    const lastClosingPrice = historicalData.length > 1 ? historicalData[historicalData.length - 2].close : 'N/A';
    const formattedLastClose = lastClosingPrice && !isNaN(lastClosingPrice) ? 
      (isBitcoin ? `$${Number(lastClosingPrice).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : 
      `₹${Number(lastClosingPrice).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
    let percentChange = indexData[currentSymbol]?.percentChange || 
      (lastClosingPrice !== 'N/A' && currentPrice !== 'N/A' && lastClosingPrice !== 0 ? 
        ((currentPrice - lastClosingPrice) / lastClosingPrice * 100) : 'N/A');
    const displayPercentChange = percentChange !== 'N/A' ? 
      `${percentChange >= 0 ? '+' : ''}${Number(percentChange).toFixed(2)}%` : 'N/A';
    const changeClass = percentChange !== 'N/A' ? 
      (percentChange < 0 ? 'stock-change negative' : 'stock-change positive') : 'stock-change';
  
    const formattedDayHigh = currentData.dayHigh && !isNaN(currentData.dayHigh) ? 
      (isBitcoin ? `$${Number(currentData.dayHigh).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : 
      `₹${Number(currentData.dayHigh).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
    const formattedDayLow = currentData.dayLow && !isNaN(currentData.dayLow) ? 
      (isBitcoin ? `$${Number(currentData.dayLow).toLocaleString('en-US', { maximumFractionDigits: 2 })}` : 
      `₹${Number(currentData.dayLow).toLocaleString('en-IN', { maximumFractionDigits: 2 })}`) : 'N/A';
  
    let actionsHtml = '';
    if (!isIndex && currentPrice && !isNaN(currentPrice) && currentSymbol && name && !['^NSEI', '^BSESN', '^NSEBANK', '^NSEMDCP50', 'BTCUSDT'].includes(currentSymbol)) {
      actionsHtml = `
        <div class="stock-actions">
          <button class="action-button buy" onclick="promptTrade('buy', '${currentSymbol}', '${name.replace(/'/g, "\\'")}', ${currentPrice})">Buy</button>
          <button class="action-button sell" onclick="promptTrade('sell', '${currentSymbol}', '${name.replace(/'/g, "\\'")}', ${currentPrice})">Sell</button>
        </div>
      `;
    }
  
    priceInfo.innerHTML = `
    <p class="${formattedCurrentPrice === 'N/A' ? 'unavailable' : 'available'}">Price: ${formattedCurrentPrice}</p>
    <p class="last-close">Last Close: ${formattedLastClose}</p>
    <p class="${changeClass}">${displayPercentChange}</p>
    <p class="day-high">Day High: ${formattedDayHigh}</p>
    <p class="day-low">Day Low: ${formattedDayLow}</p>
    ${actionsHtml}
  `;
    const percentElement = document.querySelector('#priceInfo .stock-change');
    if (percentElement && percentChange < 0) {
      percentElement.style.color = '#FF3333';
    }
  }
  
  function toggleChartType() {
    currentChartType = currentChartType === 'line' ? 'candlestick' : 'line';
    toggleChartTypeButton.textContent = `Switch to ${currentChartType === 'line' ? 'Candlestick' : 'Line'}`;
    if (currentData && activeSymbol === currentData.symbol) {
      renderChart(currentData.name, currentData.historicalData, currentData.currentPrice, currentData.volume);
    }
  }
  
  function debounce(func, wait) {
    let timeout;
    return function (...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }
  
  const autoSearch = debounce((query) => {
    if (query) {
      ws.send(JSON.stringify({ search: query }));
    } else {
      ws.send(JSON.stringify({ clearSearch: true }));
      toggleHistoricalData('^NSEI', 'NIFTY 50');
    }
  }, 500);
  
  function manualSearch() {
    const query = searchInput.value.trim();
    if (query) {
      ws.send(JSON.stringify({ search: query }));
    } else {
      ws.send(JSON.stringify({ clearSearch: true }));
      toggleHistoricalData('^NSEI', 'NIFTY 50');
    }
  }
  
  searchInput.addEventListener('input', (e) => autoSearch(e.target.value.trim()));
  
  function updateNews(newsItems) {
    const newsContainer = document.getElementById('newsContainer');
    if (!newsContainer.hasChildNodes()) {
      newsItems.forEach((item, idx) => {
        const newsCard = document.createElement('div');
        newsCard.className = 'news-card';
        newsCard.style.animationDelay = `${0.2 + (idx * 0.1)}s`;
        newsCard.innerHTML = `
          <h3 class="news-headline">${item.title}</h3>
          <p class="news-source">${item.source} • <span>${item.time}</span></p>
          <p class="news-description">${item.description}</p>
        `;
        newsContainer.appendChild(newsCard);
      });
    } else {
      const existingCards = newsContainer.querySelectorAll('.news-card');
      newsItems.forEach((item, idx) => {
        if (idx < existingCards.length) {
          const card = existingCards[idx];
          const headline = card.querySelector('.news-headline');
          const source = card.querySelector('.news-source');
          const description = card.querySelector('.news-description');
          if (headline.textContent !== item.title) headline.textContent = item.title;
          if (source.textContent !== `${item.source} • ${item.time}`) source.textContent = `${item.source} • ${item.time}`;
          if (description.textContent !== item.description) description.textContent = item.description;
        }
      });
    }
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    updateWalletBalance();
    generateDailyPredictions();
    renderPortfolio();
  });

  </script>
</body>
</html>